In this section, we detailedly describe the design details of source and path verification. \name{} enables {\tt S} to initialize the \name{} protocol and entities to perform the packet verification that is lightweight as no symmetric key need to stored. Concretely, {\tt S} uses the obtained symmetric keys to precompute the markings for each entity on $\Psi$ and inserts these markings into \name{} header, a new packet header between IP header and TCP header. During the packet delivery towards {\tt D}, each entity dynamically recomputes the secret key and then verifies the packet by recalculating the marking.
\vspace{-0.1in}
\subsection{\name{} Protocol Initialization}
\label{spmoniheaderinitialization}
\name{} protocol is initialized to make the markings for each entity calculated and inserted in packet header. \name{} enables {\tt S} to compute the markings using symmetric keys for all entities, and generates a new packet header called \name{} header to include the marking information, which is embedded between IP header and TCP header. Before sending out packets, {\tt S} initializes \name{} headers with the following structure:
%\vspace{-0.06in}
\begin{equation}\label{spmoniheader}
\emph{\name{} header} =~ \{\emph{SessionID}, \emph{epoch}, \emph{PacketID}, \emph{M}_{\emph{Path}}\}.
%\vspace{-0.06in}
\end{equation}
\noindent \emph{PacketID} is the unique packet identifier, calculated based on Eq. \ref{packetid}:
%\vspace{-0.06in}
\begin{equation}\label{packetid}
\emph{PacketID = H}(\emph{SessionID} \vert \vert \emph{epoch} \vert \vert \emph{IP}_{\emph{cst}}),
%\vspace{-0.06in}
\end{equation}
\noindent where \emph{IP}$_{\emph{cst}}$ represents constant portion of IP packet (excluding variable fields, such as TTL and checksum) during forwarding. The \emph{M}$_{\emph{Path}}$ (in Eq. \ref{spmoniheader}) denotes the precomputed marking sequence for later verification at each entity, as Eq. \ref{mpath} shows.
%\vspace{-0.06in}
\begin{equation}\label{mpath}
    \emph{M}_{\emph{Path}} ~\emph{=}~ \left \langle \emph{M}_\emph{1}, \emph{M}_\emph{2}, \cdots, \emph{M}_\emph{n}, \emph{M}_\emph{\emph{\emph{D}}} \right \rangle,
%\vspace{-0.06in}
\end{equation}
where \emph{M}$_{\emph{i}}$ is precalculated for each entity using PRF keyed with the shared symmetric keys, as Eq. \ref{mid} shows, where \emph{M}$_{\emph{cst}}^{\emph{in}}$ is the splice of constant input: $\emph{SessionID} \vert \vert \emph{epoch} \vert \vert \emph{PacketID} \vert \vert \emph{S} \vert \vert \emph{D}$. Adding source and destination address (denoted by \emph{S} and \emph{D}) as the input can also help to defense against both source spoofing and traffic redirection, caused by modifying source and destination address of IP packet.\\
\indent In Eq. \ref{mid}, \emph{TTL}$_\emph{i}$ and \emph{TTL}$_\emph{D}$ respectively donates the purposed TTL value when the packet arrives at \emph{R}$_\emph{i}$ and {\tt D}. %\emph{R}$_{\emph{i-}1}$ (\emph{1}$\leq i \leq$\emph{n}) is one-hop upstream router's address of \emph{R}$_\emph{i}$ where \emph{R}$_{\emph{i-}1}$ \emph{= S} when \emph{i =} 1.
The marking is precomputed for the entity on the reverse $\Psi$. More especially, all downstream entities' markings are added as the input, which prevents frame attack caused by malicious modification of the pre-inserted markings of downstream entities.
\vspace{-0.06in}
\begin{equation}\label{mid}
    \begin{split}
    \emph{M}_\emph{D} &~\emph{=} ~\emph{PRF}_{\emph{K}_{\emph{S,D}}}(\emph{M}_{\emph{cst}}^{\emph{in}} \vert \vert \emph{TTL}_\emph{D} \vert \vert \emph{R}_\emph{n}).\\
%    \emph{M}_\emph{n} &~\emph{=} ~\emph{PRF}_{\emph{K}_{\emph{S,R$_\emph{\emph{n}}$}}}(\emph{M}_{\emph{cst}}^{\emph{in}}\vert \vert \emph{TTL}_{\emph{n-}1} \vert \vert \emph{R}_{\emph{n-}1} \vert \vert \emph{M}_\emph{D})\\
%    & \cdots\cdots \\
    \emph{M}_\emph{i} &~\emph{=} ~\emph{PRF}_{\emph{K}_{\emph{S,R$_\emph{\emph{i}}$}}}(\emph{M}_{\emph{cst}}^{\emph{in}} \vert \vert \emph{TTL}_\emph{i} \vert \vert \emph{R}_{\emph{i-}1} \vert \vert \emph{M}_{\emph{i+}1} \vert \vert \cdots \vert \vert \emph{M}_\emph{n} \vert \vert \emph{M}_\emph{D} ).\\
    \end{split}
\vspace{-0.06in}
\end{equation}
\indent The fields \emph{SessionID}, \emph{epoch} and \emph{PacketID} in \name{} header respectively occupies 128 bits, 16 bits and 128 bits. Each marking occupies 32 bits, whose rationality analysis is shown in Section \ref{theoreticalanalysis}.
\vspace{-0.1in}
\subsection{Source and Path Verification}
\label{sourceandpathverification}
\name{} allows each intermediate entity to verify packet source and forwarding path by verifying the markings encoded in the packets. Note that \name{} enables each entity on $\Psi$ not to store the symmetric key, which can be calculated according to Eq. \ref{ksri}. This makes entities lightweight and can protect the state of exhaustion (e.g., DoS) attack. After \name{} header initialization, each packet departs from {\tt S} and is delivered through intermediate routers towards {\tt D}. During the transmission, the packet is verified for its origin and forwarding path at each hop.
%\noindent{\textbf{Source and path verification.}}
Concretely, each entity uses Eq. \ref{mid} to recalculate the marking \emph{M}$_\emph{i}'$. If the computed \emph{M}$_\emph{i}'$ equals to \emph{M}$_\emph{i}$ in \name{} header, it illustrates that the source and the forwarding path are all correct up to the current entity. Else, i.e., the verification fails, the packet will is dropped at this hop. This verification by each entity for the received packet can prevent the state exhaustion attacks on {\tt D}. 