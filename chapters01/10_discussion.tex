\noindent\textbf{Asymmetric paths.} We mainly describe the fault localization for the packet verification with symmetrical paths, while many forwarding paths between the source and the destination in the current Internet are asymmetric \cite{john2010estimating} \cite{de2015asymmetric} \cite{wassermann2016analysis}. \name{} can also provide the compatibility for asymmetric paths. With the asymmetric paths, the timer $\mathcal{T}_\emph{i}$ will expire as \emph{R}$_\emph{i}$ does not receive AckKey or AckProb packets from its downstream entities. In this case, \emph{R}$_\emph{i}$ then creates and initializes \emph{AckKey}$_\emph{i}$ or \emph{AckProb}$_\emph{i}$, which will be delivered to the source. Based on the encrypted symmetric keys or sampling information, the source can also identify and localize the misbehaved entity (see Algorithm \ref{positiveratebasedfaultlocalization}).

\noindent\textbf{Forwarding path instability.} \name{} enable the source to pre-insert the markings of entities on $\Psi$ into \name{} header for later packet verification. There is still a probability that the forwarding path $\Psi$ changes due to the link failure, network congestion, and misconfiguration, making both the packets dropped incorrectly and the fault localized wrongly. Fortunately, the network end-to-end communications keep stable from tens of minutes to several days \cite{cunha2011measuring} \cite{kang2013crossfire}. Besides, the stable forwarding paths (longer than 6 hours) will be chosen to transmit packets for 96\% of times \cite{cunha2011measuring}. To further address this problem, the source and perform \namekey{} several times until it can obtain symmetric keys of all entities on the latest purposed path $\Psi$. Using the newly obtained symmetric keys, \name{} provides a better compatibility for network instability.

\noindent\textbf{Tradeoff between robustness and overhead.} In \name{}, there is a conflict between robustness and overhead. On one hand, to ensure the robustness against unreliable communication channels, \name{} introduces the timer for each entity, which also incurs an extra overhead. Fortunately, \name{} enables each entity to use its timer only receiving request packets (i.e., ReqKey and ReqProb). This can help to lower the overhead of each entity to a certain extent. On the other hand, each entity has to store bloom filters for sampling packets. However, we think the packet sampling operation is an essential element for constructing robust fault localization. Through our analysis in Section \ref{storageoverhead}, the average storage overhead of each entity is within an acceptable range, fortunately.

\noindent\textbf{Incremental deployment.} As the packet verification is performed hop by hop, \name{}'s incremental deployment makes source and path verification paralyzed. However, it does not affect packets sampling when the entities that do not deploy \name{} ignore the packet verification. In this case, the source can still obtain the sampling information of entities and localize the fault. Due to lacking a part of sampling information, the source can only narrow the scope of the fault, which also contributes to constructing a reliable packet delivery.