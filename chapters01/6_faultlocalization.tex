\begin{algorithm}[t]
\footnotesize
\caption{ReqProb and AckProb Initialization.}
\label{reqpketinitialization}
\begin{algorithmic}[1]
\Function {\emph{ReqProb} Initialization by {\tt S}~~} { }\\
    $\textbf{Require}$: $\Psi$, $\emph{SessionID}$, \emph{epoch}, \emph{S}, \emph{D}\\
    $\textbf{Compute}$:
    %\State $\xi_{\emph{max}}^\emph{e}$ ~\emph{=}~ \emph{max}~\{$\xi_\emph{1}^\emph{e}$, $\cdots$, $\xi_{\emph{n}}^\emph{e}$, $\xi_{\emph{D}}^\emph{e}$\}
    \State $\emph{M}_{\emph{cst}}^\emph{req}$ ~\emph{=}~ $\Psi\vert \vert$\emph{SessionID}$\vert \vert$\emph{epoch}$\vert \vert$\emph{S}$\vert \vert$\emph{D}
    %\If{$\xi_{\emph{max}}^\emph{e}$ $\geq$ $\xi_{\emph{th}}^\emph{e}$} \label{iii}
    \State $\emph{M}_\emph{D}^{\emph{req}}$ \emph{=} \emph{PRF}$_{\emph{K}_{\emph{S,D}}}$($\emph{M}_{\emph{cst}}^\emph{req}\vert \vert$\emph{TTL}$_\emph{D}\vert \vert$\emph{R}$_\emph{n}$)
    \For {\emph{i} from \emph{n} to 1}
    \State $\emph{M}_\emph{i}^{\emph{req}}$ \emph{=} \emph{PRF}$_{\emph{K}_{\emph{S,D}}}$($\emph{M}_{\emph{cst}}^\emph{req}\vert \vert$\emph{TTL}$_\emph{i}\vert \vert$\emph{R}$_{\emph{i}-1} \vert \vert$\emph{M}$_{{i}+1}^{\emph{req}} \vert \vert \cdots \vert \vert$\emph{M}$_\emph{n}^{\emph{req}}\vert \vert$\emph{M}$_\emph{D}^{\emph{req}}$)
    \EndFor
    \State \emph{M}$_\emph{Path}^\emph{req}$ \emph{ = } $\langle$\emph{M}$_1^\emph{req}$, $\cdots$, \emph{M}$_\emph{n}^\emph{req}$, \emph{M}$_\emph{D}^\emph{req}\rangle$
    \State \emph{ReqProb = }\{$\Psi$, \emph{SessionID}, \emph{epoch}, \emph{M}$_{\emph{Path}}^\emph{req}$\}
    \State {\tt S} delivers \emph{REQProb} to intermediate entities towards {\tt D}.
    %\EndIf
\EndFunction
\Function {\emph{AckProb} Initialization by {\tt D}~~} { }\\
    $\textbf{Require}$: $\Psi$, $\emph{SessionID}$, \emph{epoch}, $\mathcal{B}_\emph{d}^e$, \emph{K}$_\emph{S}$, \emph{K}$_\emph{D}^{\emph{-}1}$ \\
    $\textbf{Compute}$:
    \State \emph{Enc}$\mathcal{B}_\emph{d}^e$~\emph{=}~\emph{Enc}$_{\emph{K}_{\emph{S,D}}}$($\mathcal{B}_\emph{d}^e$)
    \State \emph{Sign}$\mathcal{B}_\emph{d}^e$ \emph{=} \emph{Sign}$_{\emph{K}_\emph{D}^{\emph{-1}}}$(\emph{H}(\emph{K}$_\emph{S}\vert\vert\Psi\vert \vert$\emph{SessionID}$\vert\vert \emph{epoch} \vert \vert$\emph{TTL}$_{\emph{d}}^{\emph{ack}}\vert\vert$\emph{Enc}$\mathcal{B}_\emph{d}^e$))
    \State \emph{AckProb = }\{$\Psi$, \emph{SessionID}, \emph{epoch}, \emph{Enc}$\mathcal{B}_\emph{d}^e$, \emph{Sign}$\mathcal{B}_\emph{d}^e$\}\\
    $\textbf{Forwarding}$:
    \State {\tt D} delivers \emph{ReqProb} to intermediate entities towards {\tt S}.
\EndFunction
\iffalse
\Function {\emph{AckProb}$_\emph{i}$ Initialization by \emph{R}$_\emph{i}$~~} { }\\
    $\textbf{Require}$: $\emph{Path}^\emph{*}$, $\emph{SessionID}$, \emph{Epoch}, $\mathcal{B}_{\emph{R}_\emph{i}}^e$, \emph{K}$_\emph{S}$, \emph{K}$_{\emph{R}_\emph{i}}^{\emph{-}1}$\\
    $\textbf{Compute}$:
    \State \emph{Enc}$\mathcal{B}_{\emph{R}_\emph{i}}^e$~\emph{=}~\emph{Enc}$_{\emph{K}_{\emph{S,}{\emph{R}_\emph{i}}}}$($\mathcal{B}_{\emph{R}_\emph{i}}^e$)
    \State \emph{Sign}$\mathcal{B}_{\emph{R}_\emph{i}}^e$ \emph{=} \emph{Sign}$_{\emph{K}_{\emph{R}_\emph{i}}^{\emph{-1}}}$(\emph{H}(\emph{K}$_\emph{S}\vert\vert$\emph{Path}$^\emph{*}\vert \vert$\emph{SessionID}$\vert\vert \emph{Epoch} \vert \vert$\emph{TTL}$_{\emph{i}}^{\emph{ack}}\vert\vert$\emph{Enc}$\mathcal{B}_{\emph{R}_\emph{i}}^e$))
    \State \emph{AckProb}$_\emph{i}$\emph{ = }\{\emph{Path}$^\emph{*}$, \emph{SessionID}, \emph{Epoch}, \emph{Enc}$\mathcal{B}_{\emph{R}_\emph{i}}^e$, \emph{Sign}$\mathcal{B}_{\emph{R}_\emph{i}}^e$\}\\
    $\textbf{Forwarding}$:
    \State \emph{D} delivers \emph{AckProb}$_\emph{i}$ to intermediate entities towards \emph{S}.
\EndFunction
\fi
\end{algorithmic}
\end{algorithm}
In this section, we present the mechanism of robust fault localization. \name{} enables each entity to probabilistically sample the forwarding packets and send the sampling results to {\tt S}. Based on the positive-ratio-bound fault localization algorithm, {\tt S} can efficiently and accurately localize the fault, which also tolerates unreliable communication channels. For every epoch, {\tt S} respectively establishes one \emph{bloom filter} \cite{bloom1970space} for each entity. We define $\mathcal{B}_i^e$ and $\mathcal{B}_\emph{D}^e$ as the bloom filter with \emph{L}-bits length for the packet sampling on \emph{R}$_\emph{i}$ and {\tt D} for epoch \emph{e}, which is established by {\tt S}.\\
\indent
Before each packet's departure, {\tt S} uses probabilistic packet sampling function $\mathcal{F}$ (detailed below) to learn which entity will sample this packet. For example, if \emph{R}$_\eta$ will sample this packet according to $\mathcal{F}$, {\tt S} samples this packet in $\mathcal{B}_\eta^e$. $\mathcal{F}$ determines \emph{R}$_\emph{i}$'s packet sampling, which is only known by {\tt S} and \emph{R}$_\emph{i}$. Concretely, with the symmetric keys and \emph{PacketID} in \name{} header, {\tt S} computes and gains the 128-bit hash value:
\begin{equation}\label{hashsampling}
\emph{H}_{\emph{sampling}}\emph{=} \emph{H}(\emph{K}_{\emph{S},\emph{R}_{\emph{i}}} \vert \vert \emph{PacketID}). 
\end{equation}
We define $\omega$ as the number of selected bottom bits of \emph{H}$_{\emph{sampling}}$. If $\omega$ binaries are all equal to 0, i.e., no 1 appears in this lower $\omega$ bits binary, this packet will be sampled on the corresponding entity. In this case, $\rho$-th bit in the corresponding $\mathcal{B}_i^e$ or $\mathcal{B}_\emph{D}^e$ will be switched from 0 to 1, where $\rho ~\emph{=}~ \emph{PRF}(\emph{H}_{\emph{sampling}}),0\leq \rho < \emph{L}$. If any collision occurs, the next bit i.e., ($\rho$+1)-th bit, will be switched until no collision occurs. At the same time, each entity establishes two local bloom filters, one ($\mathcal{B}_{\emph{R}_\emph{i}}^e$ or $\mathcal{B}_\emph{d}^e$) for the current epoch and another ($\mathcal{B}_{\emph{R}_\emph{i}}^{\emph{e+}1}$ or $\mathcal{B}_\emph{d}^{\emph{e+}1}$) for the next. Note that the storage overhead is analyzed in Section \ref{theoreticalanalysis}. Then packet sampling is carried out at each entity according to $\mathcal{F}$, where the result is stored in the local bloom filter and can only be known by the corresponding entity and {\tt S}.\\
\indent
At the end of each epoch, {\tt S} tries to obtain the packet sampling information of all entities for localizing the fault by sending the request packet called \emph{ReqProb}, %But when the epoch should be switched relies on the usage rate of the bloom filter on each entity. Concretely, we respectively define $\xi_\emph{i}^\emph{e}$ and $\xi_\emph{D}^\emph{e}$ as the usage rate obtained by \emph{S} that binary 1 occupies on $\mathcal{B}_i^e$ and $\mathcal{B}_\emph{D}^e$ at \emph{Epoch} \emph{e}, where 0$<\xi_\emph{i}^\emph{e}, \xi_\emph{D}^\emph{e}<$1.
which is initialized as algorithm \ref{reqpketinitialization} shows. On receiving ReqProb, \emph{R}$_\emph{i}$ firstly performs source and path verification via recomputing \emph{M}$_\emph{i}^{\emph{req}}$, the pre-inserted marking for \emph{R}$_\emph{i}$ in ReqProb. Then \emph{R}$_\emph{i}$ starts the timer $\mathcal{T}_\emph{i}$ and forwards ReqProb to the downstream entity towards {\tt D}. When receiving ReqProb, {\tt D} initializes the probing ack packet, called \emph{AckProb}, according to algorithm \ref{reqpketinitialization}, in which the encrypted $\mathcal{B}_\emph{d}^e$ and {\tt D}'s signature are all added. Then {\tt D} sends AckProb back through entities on $\Psi$ until it arrives at {\tt S}. During AckProb transmission, each entity \emph{R}$_\emph{i}$ firstly checks all signatures in AckProb. If no error occurs, \emph{R}$_\emph{i}$ inserts its encrypted $\mathcal{B}_{\emph{R}_\emph{i}}^e$ and signature in AckProb. So the architecture of AckProb is as Eq. \ref{ackprobforwarding} shows when it arrives at \emph{R}$_\emph{i}$ and is overwritten by \emph{R}$_\emph{i}$.
\iffalse
\begin{equation}\label{ackprobarchitecture}
    \xi_{\emph{max}}^\emph{e} ~\emph{=}~ \emph{max}\{\xi_\emph{1}^\emph{e},~\cdots, ~\xi_\emph{n}^\emph{e}, ~\xi_\emph{D}^\emph{e}\},~~~~0<\xi_{\emph{max}}^\emph{e}<1
\end{equation}
\fi
%If the maximum $\xi_{\emph{max}}^\emph{e}$ among $\xi_\emph{i}^\emph{e}$ and $\xi_\emph{D}^\emph{e}$ exceeds the threshold value $\xi_{\emph{th}}$ (detailed in \ref{theoreticalanalysis}), \emph{i.e.}, $\xi_{\emph{max}}^\emph{e}\geq\xi_{\emph{th}}$, \emph{S} switches \emph{Epoch} value from \emph{e} to \emph{e'} in \emph{SPdetect} header and send the request packet \emph{REQProb} through the entities and \emph{D} on the \emph{Path}$^\emph{*}$. \emph{REQProb} is initialized as algorithm \ref{reqpketinitialization} shows.
\iffalse
\begin{equation}\label{reqprob}
\emph{REQPKT =}~ \{\emph{Path}, \emph{SessionID}, \emph{Epoch}, \emph{M}_{\emph{Path}}^{\emph{req}}\}
\end{equation}
\emph{M}$_\emph{i}^{\emph{req}}$ and \emph{M}$_\emph{D}^{\emph{req}}$ can be obtained according to Eq. \ref{mid}.
\begin{equation}\label{mreqpath}
    \emph{M}_{\emph{Path}}^{\emph{req}} ~\emph{=}~ \left \langle \emph{M}_\emph{1}^{\emph{req}}, \emph{M}_\emph{2}^{\emph{req}}, \cdots, \emph{M}_\emph{n}^{\emph{req}}, \emph{M}_\emph{\emph{\emph{D}}}^{\emph{req}} \right \rangle
\end{equation}
\fi
\begin{equation}\label{ackprobforwarding}
\begin{split}
\emph{AckProb}~\emph{=}~& \{\Psi, \emph{SessionID}, \emph{epoch}, \emph{Enc}\mathcal{B}_\emph{d}^e, \emph{Sign}\mathcal{B}_\emph{d}^e \\
                &\emph{Enc}\mathcal{B}_{\emph{R}_\emph{n}}^e, \emph{Sign}\mathcal{B}_{\emph{R}_\emph{n}}^e, \cdots, \emph{Enc}\mathcal{B}_{\emph{R}_\emph{i}}^e, \emph{Sign}\mathcal{B}_{\emph{R}_\emph{i}}^e\},
\end{split}
\end{equation}
where $\emph{Sign}\mathcal{B}_{\emph{R}_\emph{i}}^e$ uses all encrypted bloom filters of entities from \emph{R}$_\emph{i}$ to {\tt D} as the calculation input, as shown in Eq. \ref{signbri}, to prevent the previously encrypted bloom filters from malicious modification and avoids frame attack.
If the forwarding path is asymmetric\footnote{Actually, many forwarding paths in today's Internet are asymmetric \cite{john2010estimating}, which will be discussed in Section \ref{discussion}.}, \emph{R}$_\emph{i}$ will create AckProb$_\emph{i}$ to send its sampling information back to {\tt S} when $\mathcal{T}_\emph{i}$ on \emph{R}$_\emph{i}$ expires. On receiving AckProb$_\emph{i}$, \emph{R}$_\emph{j}$ (0$<j<$\emph{i}) will also check the signatures and add its $\mathcal{B}_{\emph{R}_\emph{j}}^e$ and $\emph{Sign}\mathcal{B}_{\emph{R}_\emph{j}}^e$ to \emph{AckProb}$_\emph{i}$.
\begin{equation}\label{signbri}
\begin{split}
\emph{Sign}\mathcal{B}_{\emph{R}_\emph{i}}^e ~\emph{=}~ &\emph{Sign}_{\emph{K}_\emph{i}^{\emph{-}1}}(\emph{H}(\emph{K}_\emph{S}\vert\vert\Psi\vert \vert\emph{SessionID}\vert\vert \emph{epoch}\\
&\vert \vert \emph{TTL}_{\emph{i}}^\emph{ack} \vert \vert\emph{Enc}\mathcal{B}_\emph{d}^e\vert \vert \emph{Enc}\mathcal{B}_{\emph{R}_\emph{n}}^e \vert \vert \cdots \vert \vert \emph{Enc}\mathcal{B}_{\emph{R}_\emph{i}}^e)).
\end{split}
\end{equation}

\noindent{\textbf{\emph{Positive-ration-bound} fault localization.}}
We define \emph{positive ratio} denoted by $\mathcal{P}_\emph{i}$ and $\mathcal{P}_\emph{D}$ for \emph{R}$_\emph{i}$ and {\tt D}, which illustrates the probability that the corresponding entity is misbehaved. When $\mathcal{P}_\emph{i}$ is larger than \emph{positive ratio threshold} (denoted by $\zeta$), and $\mathcal{P}_\emph{1}$, $\cdots$, $\mathcal{P}_{\emph{i-}1}$ are all less than $\zeta$, we can identify \emph{R}$_\tau$ or \emph{R}$_{\emph{i-}1}$ as the misbehaved entity.
As algorithm \ref{positiveratebasedfaultlocalization} shows, when receiving AckPorb, {\tt S} firstly checks the signatures \emph{Sign}$\mathcal{B}_{\emph{R}_\emph{i}}^e$ (1$\leq \emph{i} \leq$\emph{n}) and \emph{Sign}$\mathcal{B}_\emph{D}^e$ to verify the validity and authenticity of AckPorb. If any error occurs, {\tt S} can localize \emph{R}$_1$ as a misbehaved entity. Concretely, if \emph{R}$_\varepsilon$ (1$<\varepsilon\leq$\emph{n}) on $\Psi$ modified AckPorb, \emph{R}$_{\varepsilon\emph{-}1}, \cdots,\emph{R}_1$ will all discard AckPorb when receiving it. In this case, if AckPorb with error signatures arrives at {\tt S}, \emph{R}$_1$ either modify it or ignores the signature verification for collusion attack. Note that if no AckProb is received, {\tt S} can directly localize \emph{R}$_1$ as the fault.\\
\indent
After all signatures in AckProb are verified by {\tt S}, $\mathcal{B}_{\emph{R}_\emph{i}}^e$ and $\mathcal{B}_{\emph{d}}^e$ can be obtained by decrypting $\emph{Enc}\mathcal{B}_{\emph{R}_\emph{i}}^e$ and $\emph{Enc}\mathcal{B}_\emph{d}^e$. %With all previously computed bloom filters $\mathcal{B}_{\emph{i}}^e$ and $\mathcal{B}_{\emph{D}}^e$ of \emph{Epoch e} at \emph{S}, we define $\mathcal{C}_\emph{i}$ ($\mathcal{C}_\emph{D}$) as the count of precomputed packet sampling, \emph{i.e.}, the number of binary 1 in $\mathcal{B}_{\emph{i}}^e$ ($\mathcal{B}_{\emph{D}}^e$).
We define $\mathcal{C}_\emph{i}$ ($\mathcal{C}_\emph{d}$) as the count of packet sampling difference between precomputed sampling $\mathcal{B}_{\emph{i}}^e$ ($\mathcal{B}_{\emph{D}}^e$) and actual sampling $\mathcal{B}_{\emph{R}_\emph{i}}^e$ ($\mathcal{B}_{\emph{d}}^e$), which actually is the number of binary 1 in $\mathcal{B}_{\emph{i}}^e \bigoplus \mathcal{B}_{\emph{R}_\emph{i}}^e$ ($\mathcal{B}_{\emph{D}}^e \bigoplus \mathcal{B}_{\emph{d}}^e$).
In \name{} protocol, \emph{positive ratio} $\mathcal{P}_\emph{i}$ ($\mathcal{P}_\emph{D}$) is the ratio of $\mathcal{C}_\emph{i}$ ($\mathcal{C}_\emph{d}$) to bloom filter length \emph{L}. {\tt S} tries to find $\mathcal{P}_\tau$ ($\tau$\emph{=}1,$\cdots$\emph{, n,} {\tt D}) that meets $\mathcal{P}_\tau\geq\zeta_\tau$ and $\mathcal{P}_{\tau\emph{-}1}<\zeta_{\tau\emph{-}1}$, where $\zeta$ is the threshold of positive ratio of entity (detailed in Section \ref{performanceevaluation}). In this case, $\langle \emph{R}_{\tau\emph{-}1}, \emph{R}_{\tau} \rangle$ is localized as the misbehaved entity, because one of $\emph{R}_{\tau\emph{-}1}$ and $\emph{R}_{\tau}$ modified packet origin and path, causing the actual packet sampling in $\mathcal{B}_{\emph{R}_{\tau}}^e$ is disturbed. Note that if $\mathcal{P}_{\emph{D}}\geq\zeta_\emph{D}$ and $\mathcal{P}_{\emph{n}}<\zeta_\emph{n}$, \emph{R}$_\emph{n}$ is then localized by {\tt S}.
More generally, when {\tt S} receives \emph{AckProb}$_\emph{i}$ instead of AckProb, actual sampling results of $\emph{R}_{\emph{i+}1}$,$\cdots$, $\emph{R}_\emph{n}$, {\tt D} will be regarded as empty set, i.e., $\mathcal{B}_{\emph{R}_{\emph{i+}1}}^e$\emph{=}$\cdots$\emph{=}$\mathcal{B}_{\emph{R}_\emph{n}}^e$\emph{=}$\mathcal{B}_{\emph{d}}^e$\emph{=} $\varnothing$. Then the fault can also be localized according to algorithm \ref{positiveratebasedfaultlocalization}.
\begin{algorithm}[t]
\footnotesize
\caption{\emph{Positive-ration-bound} Fault Localization.}
\label{positiveratebasedfaultlocalization}
\begin{algorithmic}[1]
\Function {Fault Localization~~} { }\\
    $\textbf{Require}$: \emph{AckPorb}, \emph{K}$_\emph{i}$, $\mathcal{B}_{\emph{i}}^e$ (1$\leq \emph{i} \leq$\emph{n}), \emph{K}$_\emph{D}$, $\mathcal{B}_{\emph{D}}^e$, $\zeta$
    \For {1$\leq \emph{i} \leq$\emph{n}}
    \If{\textbf{!}(\emph{CheckSig}$_{\emph{K}_\emph{i}}$(\emph{Sign}$\mathcal{B}_{\emph{R}_\emph{i}}^e$) \& \emph{CheckSig}$_{\emph{K}_\emph{D}}$(\emph{Sign}$\mathcal{B}_{\emph{R}_\emph{D}}^e$))}
    \State \emph{R}$_1$ is localized as the misbehaved entity.
    \EndIf
    \State $\textbf{Compute}$: $\mathcal{B}_{\emph{R}_\emph{i}}^e$ \emph{=} \emph{Dec}$_{\emph{K}_{\emph{S,R}_\emph{i}}}$($\emph{Enc}\mathcal{B}_{\emph{R}_\emph{i}}^e$), $\mathcal{B}_{\emph{i,R}_\emph{i}}^e$ \emph{=} $\mathcal{B}_{\emph{i}}^e \bigoplus \mathcal{B}_{\emph{R}_\emph{i}}^e$
    \EndFor
    \State $\textbf{Compute}$: $\mathcal{B}_{\emph{d}}^e$ \emph{=} \emph{Dec}$_{\emph{K}_{\emph{S,D}}}$($\emph{Enc}\mathcal{B}_\emph{d}^e$), $\mathcal{B}_{\emph{D,d}}^e$ \emph{=} $\mathcal{B}_{\emph{D}}^e \bigoplus \mathcal{B}_{\emph{d}}^e$
    \For {1$\leq \emph{i} \leq$\emph{n}}
    \State $\mathcal{C}_i$:\emph{Count binary 1 in} $\mathcal{B}_{\emph{i}}^e$,  $\mathcal{C}_i'$:\emph{Count binary 1 in} $\mathcal{B}_{\emph{i,R}_\emph{i}}^e$
    \State $\textbf{Compute}$: $\mathcal{P}_\emph{i} = \mathcal{C}_i/\mathcal{C}_i'$
    \EndFor
    \State $\mathcal{C}_\emph{D}$:\emph{Count binary 1 in} $\mathcal{B}_{\emph{D}}^e$,  $\mathcal{C}_\emph{D}'$:\emph{Count binary 1 in} $\mathcal{B}_{\emph{D,d}}^e$
    \State $\textbf{Compute}$: $\mathcal{P}_\emph{D} = \mathcal{C}_\emph{D}/\mathcal{C}_\emph{D}'$, $\mathcal{P}_\emph{0} = 0$, $\mathcal{P}_\emph{D-1} = \mathcal{P}_\emph{n}$
    \For {$\tau$ \emph{from} 1 \emph{to} \emph{n} \emph{and} {\tt D}}
    \If {$\mathcal{P}_\tau \geq \zeta$ \& $\mathcal{P}_{\tau\emph{-}1}<\zeta$}
    \State $\langle \emph{R}_{\tau\emph{-}1}, \emph{R}_{\tau} \rangle$ is localized as the misbehaved entity.
    \EndIf
    \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm} 