This section discusses \name{} protocol's security against data-plane attacks (i.e., source spoofing and path inconsistency) from misbehaved entities, and sophisticated attacks resulting from unreliable detection channels. In our adversary model, the misbehaved entity can modify source address and forwarding path of received packets, disturb secret key distribution and try to corrupt fault localization. We show the \name{} protocol is secure against both a single misbehaved entity and multiple colluding entities even over unreliable communication channels.\\
\noindent{\textbf{Source spoofing.}} Modifying source address of IP packet by \emph{R}$_\tau$ will introduce discrepancies of the downstream entities' markings between the pre-inserted (by {\tt S}) and the recomputed (by downstream entities) values. For example, if \emph{R}$_\tau$ corrupts the packet source address, all downstream entities (e.g., \emph{R}$_{\tau\emph{+}1}$) will drop this received packet, because the recalculated marking \emph{M}$_{\tau\emph{+}1}^\prime$ (according to Eq. \ref{mid}) is not equal to the inserted value \emph{M}$_{\tau\emph{+}1}$ in \name{} header as the source address also act as an input of the marking calculation.\\
\noindent{\textbf{Forwarding path inconsistency.}} Corrupting the packets forwarding path will cause the non-correspondences between pre-inserted markings and downstream entities on actual forwarding path. For example, if \emph{R}$_\tau$ delivers the packets to \emph{R}$\varphi$ instead of \emph{R}$_{\tau\emph{+}1}$, \emph{R}$\varphi$ will discard this packet, because the recalculated marking \emph{M}$_\varphi^\prime$ does not equal \emph{M}$_{\tau\emph{+}1}$ in \name{} header. As for collusion attacks, we will discuss it shortly.\\
%\noindent{\textbf{Security against disturbing symmetric keys establishment.} The misbehaved router can drop, modify and redirect \emph{REQKey} or \emph{ACKKey} packet to destroy symmetric keys establishment, the precondition of data-plane source and path detection in \name{} protocol. In our proposed \emph{ASKey} mechanism, the \emph{timer} $\mathcal{T}_\emph{i}$ on each entity makes the upstream routers of \emph{R}$_\tau$ send the created symmetric keys to \emph{S}. Besides, each entity would also verify \emph{REQKey} and \emph{ACKKey} packet to avoid the modification or redirection of these two packets. More importantly, based on the acknowledgements in \emph{ACKKey}$_{(\emph{i})}$ packet, \emph{S} can locate the misbehaved router if any error occurs in the symmetric keys establishment, which makes \emph{R}$_\tau$ have to behave normally to avoid the localization.\\
\noindent{\textbf{Corrupting symmetric keys distribution.}} The misbehaved entity can drop, modify and redirect ReqKey or AckKey packet to destroy symmetric keys establishment and distribution, which is a precondition of the data-plane source and path verification in \name{} protocol. In our proposed \namekey{}, the expired timer $\mathcal{T}_\emph{i}$ on each entity enables emph{R}$_\tau$'s upstream entities to send the created symmetric keys to {\tt S}. Besides, each entity will also verify ReqKey and AckKey packet, such as the integrity and authenticity verification, to avoid the modification or redirection of these two types of packets. More importantly, based on the acknowledgements in AckKey$_{(\emph{i})}$ packet, {\tt S} can localize the misbehaved entity if any error occurs during the symmetric keys distribution, which makes \emph{R}$_\tau$ have to behave normally to avoid the fault localization.\\
\noindent{\textbf{Corrupting fault localization.}} There are three methods for \emph{R}$_\tau$ to corrupt \name{} protocol. Firstly, \emph{R}$_\tau$ can disturb the packet verification and the sampling operation by means of tampering the downstream entities' markings, which is pre-inserted in \name{} header. For example, \emph{R}$_\tau$ modifies \emph{M}$_{\tau\emph{+}2}$ in \name{} header, causing \emph{R}$_{\tau\emph{+}2}$ to drop this packet. This can frame $\langle$\emph{R}$_{\tau\emph{+}1}$\emph{,R}$_{\tau\emph{+}2}\rangle$ as a misbehaved entity. In \name{} protocol, each entity \emph{R}$_\emph{i}$ uses the downstream entities' markings (\emph{M}$_{\emph{i+}1}$,$\cdots$, \emph{M}$_\emph{D}$) in \name{} header as the inputs to recompute the marking \emph{M}$_\emph{i}^\prime$, as shown in Eq. \ref{mid}. In this case, the recomputed markings differ from the pre-inserted markings. Thus, \emph{R}$_{\tau\emph{+}1}$ will drop the packet and $\langle$\emph{R}$_{\tau}$\emph{,R}$_{\tau\emph{+}1}\rangle$ will be regarded as the fault if \emph{R}$_{\tau}$ corrupts \emph{M}$_{\tau\emph{+}\Delta}$ (2$\leq\Delta\leq$\emph{n-}$\tau$) in \name{} header.\\
\indent
Secondly, \emph{R}$_\tau$ can drop, modify and redirect \emph{ReqProb} and \emph{AckProb} packet to prevent {\tt S} from obtaining sampling information of entities. In \name{} protocol, if \emph{timer} $\mathcal{T}_{\tau\emph{-}1}$ expires, \emph{AckProb}$_{\tau\emph{-}1}$ packet will be initialized and sent back to {\tt S}. According to the \emph{positive-ratio-based} fault localization, $\mathcal{P}_\tau\geq\zeta$ and $\mathcal{P}_{\tau\emph{-}1}<\zeta$ can make $\langle$\emph{R}$_{\tau\emph{-}1}$\emph{,R}$_\tau\rangle$ easily localized.\\
\indent
Thirdly, \emph{R}$_\tau$ can frame other entities on $\Psi$ by launching TTL attack. For example, \emph{R}$_\tau$ lowers the TTL value of \emph{ReqProb} packet to a smaller value (say, $\kappa$) with the purpose that \emph{R}$_{\tau\emph{+}\kappa}$ drops this packet and can be then localized as the fault. \name{} protocol can deal with TTL attack, in which TTL value is added to compute the signatures on \emph{AckProb}$_{\emph{(i)}}$ packet during symmetric keys distribution and fault localization, and to calculate the markings on \emph{ReqProb} (see Eq. \ref{mid}) at \name{} header initialization stage. Therefore, if \emph{R}$_\tau$ launches TTL attack, the packet will be discarded at the downstream entities. In this case, \emph{R}$_\tau$ and one of its neighbor on $\Psi$ will be localized as the fault.\\
\noindent{\textbf{Collusion attacks.}} All the attacks discussed above can be also launched by more than one colluding entities. In this case, we can prove by induction that \name{} protocol works well to defense against collusion attacks. We give a proof sketch as following:\\
%\noindent{\textbf{\emph{Proof:}}} 
\indent We assume there is another entity (denoted by \emph{R}$_\sigma$, $\tau<\sigma\leq$\emph{n}) on $\Psi$ colluding with \emph{R}$_\tau$. Without loss of generality:\\
\noindent{\textbf{1)}} In the first case where \emph{R}$_\tau$ is not adjacent to \emph{R}$_\sigma$ (i.e., $\sigma>\tau$\emph{+}1), (i) if \emph{R}$_\tau$ launches the above source spoofing or path inconsistency attacks while the packets are forwarded, the intermediate entities between \emph{R}$_\tau$ and \emph{R}$_\sigma$ will also perform the verification for source and path, and then drop the corrupted packets. (ii) If \emph{R}$_\tau$ corrupts fault localization in any case of three methods described above, \emph{R}$_\tau$ and its one neighbor will be localized as the fault.\\
\noindent{\textbf{2)}} In the other case where \emph{R}$_\tau$ and \emph{R}$_\sigma$ are adjacent to each other (i.e., $\sigma$\emph{=}$\tau$\emph{+}1), we can regard these two entities as one single "virtual" misbehaved entity \emph{R}$_\emph{v}$ with upstream entity \emph{R}$_{\tau\emph{-}1}$ and downstream entity \emph{R}$_{\tau\emph{+}2}$. (i) If \emph{R}$_\emph{v}$ launches the above source spoofing or path inconsistency attack described above, \emph{R}$_{\tau\emph{+}2}$ will find the verification for packet origin and path fails, and then drop the corrupted packet. (ii) If \emph{R}$_\emph{v}$ corrupts the fault localization, {\tt S} can also obtain the packet sampling information of \emph{R}$_1$,$\cdots$, \emph{R}$_{\tau\emph{-}1}$ (i.e., $\mathcal{B}_{\emph{R}_\emph{1}}^e$,$\cdots$, $\mathcal{B}_{\emph{R}_{\tau-1}}^e$ ). In this case, at least one entity of \emph{R}$_\tau$ and \emph{R}$_\sigma$ will be localized as the misbehaved entity. 